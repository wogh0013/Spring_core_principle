인터넷 프로토콜 스택 4계층
  1. 애플리케이션 계층 - HTTP, FTP
  2. 전송 계층 - TCP, UDP
  3. 인터넷 계층 - IP
  4. 네트워크 인터페이스 계층


TCP (전송 제어 프로토콜, Transmission Control Protocol)
 1. 연결지향 - TCP 3 way handshake(가상 연결)
 2. 데이터 전달 보증
 3. 순서 보장
 4. 신뢰할 수 있는 프로토콜
 5. 현재는 대부분 TCP 사용
 6. PORT 사용
 
IP가 아파트, PORT는 몇 동 몇 호~ 
IP : 목적지 서버를 찾는 것
PORT : 같은 IP 내에서 프로세스 구분
       서버 안에서 애플리케이션들을 구분하는 것
출발지 PORT, 목적지 PORT

IP : 지정한 IP 주소에 패킷 단위로 데이터 전달
    BUT 비연결성, 비신뢰성, 포트 X 라는 한계점 존재

IP는 변경될 수 있다. IP는 기억하기 쉽지 않다.
 -> DNS(Domain Name System)
 -> 도메인명을 IP주소로 변환 

URI (Uniform Resource Identifier) - 소스를 식별하는 통합된 방법
1. Uniform    : 리소스를 식별하는 통일된 방식
2. Resource   : 자원, URI로 식별할 수 있는 모든 것
3. Identifier : 다른 항목과 구분하는 데 필요한 정보
 - URL (Uniform Resource Locator) : 리소스가 있는 위치를 지정
 - URN (Uniform Resource Name)    : 리소스의 이름 
 - 위치는 변할 수 있지만, 이름은 변하지 않는다.
 - URI 와 URL은 거의 같은 의미임.

 URL scheme
  scheme://[userinfo@]host[:port][/path][?query][#fragment]
  https://www.google.com:443/search?q=hello?hl=ko
    - 주로 프로토콜 사용(http, https, ftp 등)
    - 프로토콜 : 어떤 방식으로 자원에 접근할 것인가?하는 규칙
    - 주로 http는 80포트, https는 443포트 사용 (포트는 생략 가능)
    - https는 http에 보안 추가(HTTP Secure)
    - 요즘 대부분 https 사용

    - host : 호스트명, 도메인명 또는 IP주소를 직접 사용
    - port : 접속 포트, 일반적으로 생략, http 80, https 443
    - path : 리소스 경로, 계층적 구조 (/home/file1.jpg, /members/100 ..)
    - query : key=value 형태, ?로 시작, &로 추가 가능(?keyA=valueA&keyB=valueB)
             query parameter, query string 등으로 불림     
    - fragment : 서버에 전송되는 정보는 X, 잘 사용X

HTTP 메시지 전송
 1. 웹 브라우저가 HTTP 메시지 생성
 2. SOCKET 라이브러리를 통해 전달
  - A: TCP/IP 연결(IP, PORT)
  - B: 데이터 전달
 3. TCP/IP 패킷 생성, HTTP 메시지 포함


 HTTP(HyperText Transfer Protocol)
  : HTTP 메시지에 모든 것을 전송한다.
  - HTML, TEXT, IMAGE, 음성, 영상, 파일
  - JSON, XML (API) 등 거의 모든 형태의 데이터 전송 가능
  - 서버 간 데이터 전송도 대부분 HTTP 사용
  - 특징
   1. 클라이언트-서버 구조
     : 클라이언트가 Request(요청)를 보내면, 서버가 Response(응답)을 해서 동작
   2. 무상태 프로토콜(stateless), 비연결성
      stateless : 서버가 클라이언트의 상태를 보존 X
                  클라이언트 요청 증가 -> 서버 대거 투입 가능
                  응답 서버를 쉽게 바꿀 수 있음(무한한 서버 증설 가능)
                  웹을 설계할 때 최대한 무상태, 어쩔 수 없을 때만 상태유지
      비연결성 : 매우 빠른 속도로 응답
                수천 명이 서비스를 사용해도, 실제 서버에서 동시에 처리하는 요청은 적음
                서버 자원을 매우 효율적으로 사용 가능
                But, TCP/IP 연결을 새로 해야 함 -> 시간 낭비
                      -> 지속 연결(Persistent Connections)로 문제 해결                   
   3. HTTP 메시지
   4. 단순함, 확장 가능

HTTP 메시지 구조
 1. start-line 시작 라인
  - request-line(요청 메시지) 
    1) HTTP 메서드 (GET, POST, DELETE ..) 
    2) 요청 대상 (\절대경로[?쿼리])
    3) HTTP 버전
  - status-line(응답 메시지)
    1) HTTP 버전
    2) HTTP 상태 코드(요청 성공, 실패를 나타냄 / 200:성공, 400:클라이언트 요청 오류, 500:서버 내부 오류)
    3) 이유 문구
 2. HTTP header 헤더
  - HTTP 전송에 필요한 모든 부가정보가 들어가있음
 3. empty line 공백 라인 (CRLF)
 4. HTTP message body 바디
  - 실제 전송할 데이터
  - HTML 문서, 이미지, 영상, JSON 등 byte로 표현할 수 있는 모든 데이터 전송 가능
  
API URI 설계
 - 리소스란 ?
  ex) 회원을 등록, 수정하는 것이 리소스가 아니라
      회원이라는 개념 자체가 '리소스'이다.
 - 이 리소스를 URI에 매핑하면 된다.
 - URI는 리소스만 식별한다.
 - '리소스'와 해당 리소스를 대상으로 하는 '행위(메서드)'를 분리한다.
  리소스: 회원
  행위(메서드): 조회, 등록, 삭제, 변경 -> HTTP 메서드

HTTP 메서드: 클라이언트가 서버에 무언가를 요청할 때 기대하는 행동
             서버가 수행해야 할 동작 지정
 1. GET
  - 리소스 조회
  - 서버에 전달하고 싶은 데이터는 쿼리를 통해서 전달 
 2. POST
  - 요청 데이터 처리 
  - 메시지 바디를 통해 서버로 요청 데이터 전달 -> '서버야 데이터 처리해줘'
     -> 서버는 요청 데이터를 처리한다.
     -> 주로 전달된 데이터로 새로운 리스소 등록, 
        단순히 데이터를 다루는 것을 넘어 프로세스를 처리해야 할 때도 사용
  - 리소스 URI에 POST 요청이 오면, 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 함
 3. PUT
  - 리소스가 있으면 '완전히' 대체함(덮어버림)
  - 리소스가 없으면 생성
  - 클라이언트가 리소스를 알고 있음(리소스 위치를 알고 URI 지정)
     -> POST와의 차이점
 4. PATCH
  - 리소스 '부분' 변경
 5. DELETE
  - 리소스 삭제

HTTP 메서드 특징
 1. 안전
  - 호출해도 리소스를 변경하지 않는다.
 2. 멱등 : 한 번 호출하든 백 번 호출하든 결과가 똑같다.
  - GET : 한 번 조회하든, 두 번 조회하든 같은 결과과 조회된다.
  - PUT : 결과를 대체한다. 따라서 같은 요청을 여러 번 해도 최종 결과는 같다.
  - DELETE : 결과를 삭제한다. 같은 요청을 여러 번 해도 삭제된 결과는 같다.
  - POST : 멱등이 아니다. 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.   
    * 멱등은 외부 요인으로 중간에 리소스가 변경되는 것까지는 고려하지 않는다.
      동일한 사용자가 똑같은 행동을 반복하는 것에 대해서만 고려한다.  
  3. 캐시 가능
   - 웹 브라우저가 내부에 저장(GET정도만 캐시로 사용)

클라이언트에서 서버로 데이터 전송
 - 데이터 전달 방식
  1. 쿼리 파라미터
   - GET
   - 주로 정렬 필터(검색어)
  2. 메시지 바디
   - POST, PUT, PATCH
   - 회원가입, 상품 주문, 리소스 등록, 리소스 변경

- 데이터를 전송하는 4가지 상황   
 1. 정적 데이터 조회
  - 이미지, 정적 텍스트 문서
 2. 동적 데이터 조회
  - 검색, 게시판 목록에서 정렬 필터(검색어)
  - 조회는 GET 사용, GET은 쿼리 파라미터를 사용해서 데이터 전달
 3. HTML Form을 통한 데이터 전송
  - sumbit 시 POST 전송(회원가입, 상품 주문, 데이터 변경)
  - ContentT-Type: application/x-www-form-urlencoded 사용 (form의 내용을 메시지 바디를 통해 전송, key=value 형식)
                   multipart/form-data (파일 업로드 같은 바이너리 데이터 전송 시 사용, 여러 개 함께 전송 가능)
  - GET 전송도 가능
  - 즉, Form 전송은 GET, POST만 지원
 4. HTTP API를 통한 데이터 전송
  - 회원가입, 상품 주문, 데이터 변경
  - 서버 to 서버(백엔드), 앱 클라이언트(아이폰, 안드로이드), 웹 클라이언트(Ajax)
  - GET: 조회 / 쿼리 파라미터로 데이터 전달
  - POST, PUT, PATCH: 메시지 바디로 데이터 전달
  - Content-Type: application/json을 주로 사용(표준), + XML  

파일 관리 시스템
 - API 설계: PUT 기반 등록
  - 파일 목록 /files -> GET
  - 파일 조회 /files/{filename} -> GET
  - 파일 등록 /files/{filename} -> PUT  //기존 파일을 덮어버리거나 새로 생성
  - 파일 삭제 /files/{filename} -> DELETE
  - 파일 대량 등록 /files -> POST
 - PUT 신규 자원 등록 특징
  - 클라이언트가 리소스 URI를 알고 있어야 한다. (PUT /files/star.jpg)
  - 클라이언트가 직접 리소스 URI를 지정한다.
  - 스토어: 클라이언트가 관리하는 리소스 저장소 (ex. /files)
            클라이언트가 리소스 URI를 알고 관리

HTTP API - 컬렉션
 - POST 기반 등록
 - 서버가 리소스 URI 결정
HTTP API - 스토어
 - PUT 기반 등록
 - 클라이언트가 리소스 URI 결정
HTML FORM 사용
 - 순수 HTML + HTML form 사용
 - GET, POST만 지원

URI 설계 개념
 1. 문서: 단일 개념 (/members/100, /files/star.jpg)
 2. 컬렉션: 서버가 리소스 URI를 생성하고 관리, 리소스 디렉터리 (/members) *가장 많이 사용*
 3. 스토어: 클라이언트가 리소스 URI를 알고 관리 (/files)
 4. 컨트롤 URI: 위 3가지로 해결하기 어려운 추가 프로세스 실행, 동사 사용 (/memers/{id}/delete)


클라이언트 ---------------- 서버
상태 코드: 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능
 (1) 1xx : 요청이 수신되어 처리 중 (거의 사용 X)
 (2) 2xx : 요청 정상 처리 (성공)
    1) 200 OK: 요청 성공
    2) 201 Created: 새로운 리소스가 생성됨
    3) 202 Accepted: 요청은 접수 but 처리 완료 X
    4) 204 No Content: 요청은 성공적 수행 but 응답 페이로드로 보낼 데이터 X
 (3) 3xx : 요청을 완료하려면 추가 행동 필요 (리다이렉션)
    리다이렉션: 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동
     - 영구 리다이렉션(301, 308): 특정 리소스의 URI가 영구적으로 이동 (/event -> /new-event)
     - *일시 리다이렉션(302, 307, 303): 리소스 URI가 일시적으로 변경(주문완료 후 주문내역화면으로 이동)
           PRG(Post/Redirect/Get)
            - POST로 주문 후에 새로고침으로 인한 중복 주문 방지
            - POST로 주문 후에 주문 결과 화면을 GET 메서드로 리다이렉트
            - 새로고침해도 중복 주문 대신, 결과 화면을 GET으로 조회
            -> URL이 이미 POST -> GET으로 리다이렉트됨 (새로고침해도 결과 화면만 조회)
     - 특수 리다이렉션: 결과 대신 캐시를 사용
    1) 301 Moved Permanently: POST -> GET, 메시지 바디 삭제(maybe)
    2) 302 Found: 요청 메서드 -> GET, 본문 제거(maybe)
    3) 303 See Other: 요청 메서드 -> GET
    4) 304 Not Modified: 캐시를 목적으로 사용, 캐시로 리다이렉트함
    5) 307 Temporary Redirect: 요청 메서드와 본문 유지(must)
    6) 308 Permanent Redirect: POST 유지, 메시지 바디 유지(must)
 (4) 4xx : 클라이언트 오류, 서버가 요청 수행을 할 수 없음
  - 오류의 원인이 클라이언트임
  - 이미 클라이언트가 잘못된 요청, 데이터를 보내고 있음
     -> 요청을 재시도해도 실패함
  - 클라이언트는 요청 내용을 다시 검토하고 보내야 함   
    1) 401 Unauthorized: 인증되지 않음
        인증(Authentication): 본인이 누구인지 확인(로그인)
        인가(Authorization): 권한부여(특정 리소스에 접근할 수 있는 권한)
         순서 : 인증 -> 인가
    2) 403 Forbidden: 서버가 요청을 이해했지만, 승인을 거부함
    3) 404 Not Found: 요청 리소스가 서버에 없음      
 (5) 5xx : 서버 오류, 서버가 정상 요청을 처리하지 못함
  - 오류의 원인이 서버임
  - 요청을 재시도했을 때, 서버가 복구됐을 때 성공할 수 있음
    1) 500 Internal Server Error: 서버 문제로 오류 발생(가장 빈번)
    2) 503 Service Unavailable: 과부하 or 예정작업으로 인한 서비스 이용 불가

HTTP 헤더
 - HTTP 전송에 필요한 모든 부가정보
 1) General 헤더: 메시지 전체에 적용되는 정보
 2) Request 헤더: 요청 정보
 3) Response 헤더: 응답 정보
 4) Entity 헤더: 엔티티 바디 정보
HTTP 바디
 - 메시지 본문(페이로드)을 통해 표현 데이터 전달
 - 표현: 요청이나 응답에서 전달할 실제 데이터
표현
 - Content-Type: 표현 데이터 형식
 - Content-Encoding: 표현 데이터 압축 방식
 - Content-Language: 표현 데이터 자연 언어
 - Content-Length: 표현 데이터 길이
협상(클라이언트가 선호하는 표현 요청)
 - Accpet: 클라이언트가 선호하는 미디어 타입 전달   
 - Accept-Charset
 - Accept-Language
 - Accept-Length
전송방식
 - 단순 전송
 - 압축 전송
 - 분할 전송
 - 범위 전송 
일반 정보
 - From: 유저 에이전트의 이메일 정보
 - *Referer: 이전 웹 페이지 주소(유입 경로 분석 가능)
 - User-Agent: 유저 에이전트 애플리케이션 정보
 - Server: 요청을 처리하는 오리진 서버의 소프트웨어 정보
 - Date: 메시지가 생성된 날짜
특별한 정보
 - *Host: 요청한 호스트 정보(도메인), 하나의 IP 주소에 여러 도메인이 적용돼있을 때
 - Location: 페이지 리다이렉션
 - Allow: 허용 가능한 HTTP 메서드
 - Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
인증
 - Authorization: 클라이언트 인증 정보를 서버에 전달
 - WWW-Authenticate: 리소스 접근 시 필요한 인증 방법 정의

 쿠키
  - Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
  - Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청 시 서버로 전달
  - HTTP는 무상태 프로토콜(스테이스리스)  
    -> 클라이언트와 서버가 요청과 응답을 주고 받으면, 연결이 끊어진다.
    -> 클라이언트가 다시 요청하면 서버는 이전 요청을 기억하지 못한다.
    -> 클라이언트와 서버는 서로 상태를 유지하지 않는다.
  - 주로 사용자 로그인 세션 관리, 광고 정보 트래킹에 사용
  - 생명 주기
    - 세션 쿠키: 만료 날짜 생략 -> 브라우저 종료 시까지 유지
    - 영속 쿠키: 만료 날짜 입력 -> 해당 날짜까지 유지    
  - 도메인을 명시 -> 해당 도메인 + 서브 도메인을 쿠키로 접근 가능
  - 경로(path): 이 경로를 포함한 하위 경로 페이지만 쿠키 접근(path=/home..)
  - 보안
    - Secure: 적용하면 https인 경우에만 전송
    - HttpOnly: HTTP 전송에만 사용
    - SameSite: 요청 도메인 = 쿠키 도메인일 때만 쿠키 전송

캐시
 - 캐시 가능 시간동안 네트워크 사용할 필요 X
 - 브라우저 로딩 속도가 매우 빠름(빠른 사용자 경험), 캐시에서 바로 꺼내오니까
 - 캐시 유효시간이 초과되면, 서버를 통해 데이터 다시 조회 -> 캐시 갱신 -> 네트워크 다운로드 발생
 - 캐시 만료 후에도 서버에서 데이터 변경 X
   -> 캐시 재사용 가능
   -> But, 클라이언트 데이터 = 서버 데이터인 사실을 확인할 수 있는 방법이 필요함
   -> 검증 (검증 헤더 추가)
 - 캐시 유효시간이 초과돼도 서버의 데이터가 갱신되지 않으면
   -> 304 Not Modified와 헤더 메타 정보만 응답(바디 부분 X)
   -> 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보 갱신
   -> 클라이언트는 캐시에 저장되어 있는 데이터 재활용 
   -> 용량이 적은 헤더 정보만 다운로드 -> 네트워크 다운로드 용량 ↓
 - 검증 헤더: 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  (1) Last-Modified
   - If-Modified-Since: 이후에 데이터가 수정되었으면?
      1) 데이터 미변경 시
       - 304 Not Modified, 헤더 데이터만 전송(Body 미포함)
       - 전송 용량 0.1M
      2) 데이터 변경 시
       - 200 OK, 모든 데이터 전송(Body 포함)  
       - 전송 용량 1.1M
  (2) *Etag
   - If-None-Match: E-tag만 보내서 같으면 유지, 다르면 다시 받기(단순)
       - 캐시 제어 로직을 완전히 서버에서 관리

캐시 제어 헤더
 1) *Cache-Control: 캐시 제어
   - max-age: 캐시 유효시간(초 단위)
   - no-cache: 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
   - no-store: 데이터에 민감한 정보가 있으므로 저장하면 안됨(사용 후 최대한 빨리 삭제)
   - must-revalidate: 캐시 만료 후 최초 조회 시, 원 서버에 검증해야 함
   - public: 응답이 public 캐시에 저장되어도 됨
   - private: 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함
 2) Pragema: 캐시 제어(하위 호환)
 3) Expires: 캐시 유효기간(하위 호환)































































