<좋은객체지향설계원칙>
1.SRP 단일 책임 원칙
 - 한 클래스는 하나의 책임만 가져야 한다.
 - 관심사 분리
 - 클라이언트 객체 : 실행 담당
 - AppConfig : 구현 객체 생성 및 연결 담당

2. DIP 의존관계 역전 원칙
 - 프로그래머는 "추상화에 의존해야지, 구체화에 의존해선 안된다."
   의존성 주입은 이 원칙을 따르는 방법 중 하나다.
 - 클라이언트 코드가 추상화 인터페이스(DiscountPolicy)에만 의존하도록 코드 변경.
 - 하지만 클라이언트 코드는 인터페이스만으로는 아무것도 못함.
    -> AppConfig가 클라이언트 코드 대신 구현 클래스(FixDiscountPolicy)를 생성한 후,
       클라이언트 코드에 의존관계 주입.

3. OCP
 - 소프트웨어 요소는 확장에는 열려있으나, 변경에는 닫혀있어야 한다.
 - 애플리케이션(사용 영역 + 구성 영역)
 - AppConfig가 의존관계를 FixDiscountPolicy -> RateDiscountPolicy롤 변경해서
   클라이언트 코드에 주입하므로 클라이언트 코드는 변경하지 않아도 됨.
 - 소프트웨어 요소를 새롭게 확장해도 사용 영역의 변경은 닫혀있다.



 ----------
IoC(제어의 역전) : 프로그램의 제어 흐름을 직접 제어하는 것이 아니라, 외부(여기선 AppConfig)에서 관리하는 것.

 프레임워크 : 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행 (JUnit)
 라이브러리 : 내가 작성한 코드가 직접 제어의 흐름을 담당


DI(의존관계 주입) : OrderServiceImpl은 DiscountPolicy인터페이스에 의존한다.
                 실제 어떤 구현 객체가 사용될지는 모른다.
                 - 애플리케이션 실행시점(런타임)에 외부에서 실제 구현 객체를 생성 -> 클라이언트에 전달
                   -> 클라이언트와 서버의 실제 의존관계가 연결되는 것.
                 - 의존관계 주입 사용 -> 정적인 클래스 의존관계를 변경하지 않고, 동적인 클래스 의존관계 변경 가능
 의존관계
 1. 정적인 클래스 의존 관계 : 애플리케이션을 실행하지 않아도, import 코드만 보고 의존관계 파악
 2. 동적인 클래스 의존 관계 : 애플리케이션 실행 전에는 의존관계를 모름.(실행 시점에 의존관계 연결)


 DI(IoC) 컨테이너 : 객체를 생서하고 관리하면서 의존관계를 연결해주는 것(여기서는 AppConfig)


ApplicationContext는 스프링 컨테이너다.
 ㄴ @Configuration이 붙은 AppConfig를 설정정보로 사용한다.
 ㄴ @Bean이 붙은 메서드를 모두 호출 -> 반환된 객체를 스프링 컨테이너에 등록한다.
     -> 스프링 컨테이너에 등록된 객체를 스프링 빈이라고 한다.
     -> Bean : 빈 이름은 항상 다른 이름을 부여해야 한다.(메서드 이름)

스프링 빈 조회 : 부모 타입으로 조회 -> 자식 타입도 함께 조회됨
 따라서 모든 객체의 최고 부모인 Object 타입으로 조회하면, 모든 스프링 빈을 조회한다.


BeanFactory (스프링 컨테이너)
- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리, 조회
- getBean() 제공

ApplicationContext (★스프링 컨테이너)
- BeanFactory 기능을 모두 상속받아서 제공해줌
  ㄴ 근데 왜 따로 사용하냐?
     -> 애플리케이션을 개발하는데는 수많은 부가기능이 있음
     -> 이들을 모두 상속받아야 함 !
- Bean 관리 기능 + 편리한 부가 기능
  ㄴ 따라서 ApplicationContext를 더 많이 사용한다.


싱글톤 패턴
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장해주는 디자인 패턴
- private 생성자를 사용 -> 외부에서 임의로 new 키워드 사용 방지

싱글톤 자체로는 장단점이 있지만
스프링 컨테이너는 싱글톤 패턴을 적용해주기 때문에 장점만 있음 !

- 여러 클라이언트가 하나의 같은 객체 인스턴스 공유
  -> 싱글톤 객체는 상태를 유지하게 설계하면 안된다.
     1. 무상태로 설계
     2. 특정 클라이언트에 의존하는 필드가 있으면 X
     3. 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 X
     4. 가급적 읽기만 가능하게 (수정 X)
     5. 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용
          -> 공유되는 변수(전역변수)를 사용하지 말자 !
          -> 왜? 같은 변수를 사용하다보니 값이 누적이 됨
          -> 지역변수를 사용 !
- @Bean만 사용해도 스프링 빈으로 등록됨 But 싱글톤 보장 X
  스프링 설정 정보는 항상 @Configuration을 사용하자. -> 싱글톤 보장 O

@ComponentScan(컴포넌트 스캔)
- @Component 애너테이션이 붙은 클래스를 스프링 빈으로 등록
@Autowired
- 자동 의존관계 주입
- 생성자가 1개일 때는 생략 가능

-> 따라서 @Component와 @Autowired는 같이 쓰인다.
        (스프링빈 등록) (의존관계 주입)

- @ComponetScan의 탐색위치를 지정하는 basePackages는 사용권장 X
   -> 프로젝트 시작 루트(최상단)에 위치시키면 하위 패키지는 모두 자동으로 컴포넌트 스캔의 대상이 된다.

컴포넌트 스캔 기본 대상
- @Component : 컴포넌트 스캔에서 사용
- @Controller : 스프링 MVC 컨트롤러에서 사용
- @Service : 스프링 비즈니스 로직에서 사용
- @Repository : 스프링 데이터 접근 계층에서 사용
- @Configuration : 스프링 설정 정보에서 사용

중복등록과 충돌
- 자동 빈 등록 vs 자동 빈 등록
    -> 에러 발생
- 수동 빈 등록 vs 자동 빈 등록
    -> 문제 X (수동 빈이 자동 빈을 오버라이딩해버림)


의존관계 주입을 [생성자 주입]으로 해야 하는 이유 !
1. "불변"
 - 대부분 의존관계 주입은 한 번 일어나면 종료시까지 변경할 일 거의 X
 - 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출될 일 X -> 불변
2. "누락 방지"
3. "final 키워드"를 넣을 수 있다.
 - 초기값이나 생성자에서만 값을 줄 수 있음.
 - 생성자에서 값이 설정되지 않는 오류를 컴파일 시점에 방지해준다.
4. 가끔 옵션이 필요할 때 수정자 주입을 선택! (생성자 주입 + 수정자 주입 동시 사용 가능)


lombok(롬복)
- @Getter
- @Setter
- @ToString
- @RequiredArgsConstructor
  ㄴ final 키워드가 붙은 인스턴스를 매개변수로 받는 생성자를 자동으로 만들어줌
     코드에는 보이지 않지만 실제 호출이 가능함
- 생성자 관련
- 등등.....

조회된 빈이 2개 이상인 경우(문제 발생) - 해결방안
1. @Autowired 필드명 매칭
   1) 타입 매칭
   2) 타입 매칭 결과가 2개 이상 -> 필드명, 파라미터명으로 빈 이름 매칭
2. @Qualifier -> @Qualifier끼리 매칭 -> 빈 이름 매칭
   1) @Qualifier끼리 매칭
   2) 빈 이름 매칭
   3) 그래도 없다? -> 예외 발생
3. @Primary 사용
   - 우선순위를 정하는 방법
   - @Autowired 시 여러 빈이 매칭되면 @Primary 애너테이션이 있는 빈이
     우선순위가 되어 지정된다.

-> @Primary는 기본값 동작, @Qualifier는 상세한 동작
   따라서 우선권은 @Qualifier가 더 높다.
-> 메인 DB와 연관있는 스프링 빈은 @Primary 지정 (매번 @Qualifier를 작성해야 하는 번거로움 X)
   서브 DB와 연관있는 스프링 빈은 @Qualifier 지정

조회한 빈이 모두 필요할 때 -> Map, List

자동 빈 등록 : 업무 로직 빈
수동 빈 등록 : 기술 지원 빈


스프링 빈의 라이프사이클
 객체 생성 -> 의존관계 주입

스프링 빈의 이벤트 라이프사이클
 - 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입
   -> 초기화 콜백 -> 사용 -> 소멸 전 콜백 -> 스프링 종료

  *초기화 콜백  : 빈 생성 -> 빈의 의존관계 주입 완료 -> 초기화 콜백 호출
  *소멸 전 콜백 : 빈이 소멸되기 직전에 호출

  - 객체의 생성과 초기화는 분리한다 (유지보수 때문)
   생성자 : 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성
   초기화 : 이렇게 생성된 값을 활용 -> 외부 커넥션을 연결(무거운 동작)

  @PostConstruct, @PreDestroy 애너테이션
   - 가장 편리하게 초기화와 종료를 실행할 수 있다.
   - 외부 라이브러리에 적용하려면 @Bean기능을 사용해야 함.

싱글톤 빈 (대부분 싱글톤 빈을 사용함)
 - 스프링 컨테이너 생성 시점에 초기화 메서드 실행
 - 스프링 컨테이너가 관리
    ㄴ 스프링 컨테이너가 종료될 때 빈의 종료 메서드가 실행됨

프로토타입 빈
 - 스프링 컨테이너가 생성, 의존관계 주입, 초기화까지만 관여
 - 스프링 컨테이너가 종료될 때 종료 메서드가 실행되지 않음
 - 프로토타입 빈을 조회한 클라이언트가 관리해줘야 함(종료 메서드도 직접!)
 - 스프링 컨테이너에 요청할 때마다 새로 생성됨

















